# Домашка к 2024-12-29

Сегодня на занятии мы продолжили рассмотрение CSS-стилизации.

## Теория

Рекомендую канал [Александр Ламков — Friendly Frontend | YouTube](https://www.youtube.com/@AleksanderLamkov/). Автор снимает крутейшие видосы по фронденд-разработке, обясняя понятным языком различные аспекты.

### [CSS-селекторы](https://youtu.be/GctszxSvbeQ?si=bG0W7ArfWYcSimgv)

По ссылке в заголовке этого пункта - крутейший видос по нашей теме, очень рекомендую к просмотру, многие вещи для данного раздела брал из этого видео. Видео **обязательно к просмотру**!

Мне оооочень лень было писать примеры использования, так что гляньте все тот же видос.

#### Селектор по тэгу

Данный селектор выбирает все объекты на странице, по названию тэга. Синтаксис - просто название тэга:

```css
html { /* стили для всех объектов с тэгом html */ }
body { /* стили для всех объектов с тэгом body */ }
p { /* стили для всех объектов с тэгом p */ }
li { /* стили для всех объектов с тэгом li */ }
div { /* стили для всех объектов с тэгом div */ }
main { /* стили для всех объектов с тэгом main */ }
```

Таким образом можно выбрать абсолютно любой тэг на странице.

#### Селектор по классу

Данный селектор выбирает все объекты на странице, у которых атрибут `class` содержит указанное значение. Синтаксис - точка и название класса:

```css
.main-container { /* стили для всех объектов, у которых есть класс main-container */ }
.link { /* стили для всех объектов, у которых есть класс link */ }
.card { /* стили для всех объектов, у которых есть класс card */ }
.sub-title { /* стили для всех объектов, у которых есть класс sub-title */ }
.img { /* стили для всех объектов, у которых есть класс img */ }
```

Таким образом можно выбрать объект с абсолютно любым классом.

#### Селектор по идентификатору

Данный селектор выбирает все объекты на странице, у которых атрибут `id` равен указанному значению. Синтаксис - символ решетки и значение идентификатора:

```css
#buy-btn { /* стили для объекта, у которого атрибут id равен buy-btn */ }
#password-field { /* стили для объекта, у которого атрибут id равен password-field */ }
#auth-form { /* стили для объекта, у которого атрибут id равен auth-form */ }
#submit-btn { /* стили для объекта, у которого атрибут id равен submit-btn */ }
```

Таким образом можно выбрать объект с абсолютно любым id-шником.

#### Селектор по атрибуту

Данный селектор выбирает все объекты на странице, у которых атрибут присутствует указанный атрибут. Синтаксис - название атрибута и иногда символ `=` и значение этого атрибута в кавычках или без них, все выражение заключено в квадратные скобки:

```css
[placeholder] { /* стили для всех объектов, у которых присутствует атрибут placeholder */ }
[class] { /* стили для всех объектов, у которых присутствует атрибут class */ }
[type=submit] { /* стили для всех объектов, у которых присутствует атрибут type со значением "submit" */ }
[target="_blank"] { /* стили для всех объектов, у которых присутствует атрибут target со значением "_blank" */ }
```

Таким образом можно выбрать объекты с абсолютно любыми атрибутами.

Данный селектор очень гибкий и имеет множество вариаций:

- Значение атрибута содержит фрагмент:
    ```css
    [placeholder*="abo"] { /* стили для всех объектов, у которых присутствует атрибут placeholder со значением, содержащим строку "abo" */ }
    [href*="github.com"] { /* стили для всех объектов, у которых присутствует атрибут href со значением, содержащим строку "github.com" */ }
    ```

- Значение атрибута содержит слово (набор символов, обособленный пробелами):
    ```css
    [placeholder~="user"] { /* стили для всех объектов, у которых присутствует атрибут placeholder со значением, содержащим слово "user" */ }
    [alt~="abobus"] { /* стили для всех объектов, у которых присутствует атрибут alt со значением, содержащим слово "abobus" */ }
    ```

- Значение атрибута точно соответствует фрагменту или начинается с него и дальше идет символ дифиса (`-`):
    ```css
    [placeholder|="Hello"] { /* стили для всех объектов, у которых присутствует атрибут placeholder со значением, равным "Hello" или начинающимся с фрагмента "Hello-" */ }
    [class|="main"] { /* стили для всех объектов, у которых присутствует атрибут class со значением, равным "main" или начинающимся с фрагмента "main-" */ }
    ```

- Значение атрибута начинается с фрагмента:
    ```css
    [href^="https://"] { /* стили для всех объектов, у которых присутствует атрибут href со значением, начинающимся на "https://" */ }
    [src^="../"] { /* стили для всех объектов, у которых присутствует атрибут src со значением, начинающимся на "../" */ }
    ```

- Значение атрибута заканчивается фрагментом:
    ```css
    [href$=".ru"] { /* стили для всех объектов, у которых присутствует атрибут href со значением, заканчивающимся на ".ru" */ }
    [src$=".png"] { /* стили для всех объектов, у которых присутствует атрибут src со значением, заканчивающимся на ".png" */ }
    ```

- Игнорирование регистра в значении атрибута:
    ```css
    [placeholder|="main" i] { /* стили для всех объектов, у которых присутствует атрибут placeholder со значением, равным "main" или начинающимся с фрагмента "main-", при этом регистр букв игнорируется */ }
    [alt*="gnome" i] { /* стили для всех объектов, у которых присутствует атрибут alt со значением, содержащим строку "gnome", при этом регистр букв игнорируется */ }
    ```

#### Универсальный селектор

Данный селектор выбирает абсолютно все объекты на странице. Синтаксис - символ звездочки:

```css
* { /* стили для абсолютно всех объектов на странице */ }
```

#### Селектор потомка

Данный селектор выбирает на странице все объекты указанного селектора, являющиеся потомками всех указанных объекторв. Синтаксис - селектор предка, пробел, селектор потомка:

```css
body a {
    /* стили для всех объектов с тэгом a, являющихся потомками объектов с тэгом body */
}
.main-container p {
    /* стили для всех объектов с тэгом p, являющихся потомками объектов с классом main-container */
}
.card .img {
    /* стили для всех объектов с классом img, являющихся потомками объектов с классом card */
}
#auth-form p {
    /* стили для всех объектов с тэгом p, являющихся потомками объекта с индексом auth-form */
}
main .cards .txt {
    /* стили для всех объектов с классом txt, являющихся потомками объектов с классом cards, являющихся потомками объектов с тэгом main */
}
```

Таким образом можно выбрать объекты являющиеся потомками каких угодно объектов.

#### Селектор дочернего элемента

Данный селектор выбирает на странице все объекты указанного селектора, являющиеся дочерними всех указанных объекторв. Синтаксис - селектор родителя, символ `>`, селектор дочернего элемента:

```css
body > a {
    /* стили для всех объектов с тэгом a, являющихся дочерними элементами объектов с тэгом body */
}
.main-container p {
    /* стили для всех объектов с тэгом p, являющихся дочерними элементами объектов с классом main-container */
}
.card > .img {
    /* стили для всех объектов с классом img, являющихся дочерними элементами объектов с классом card */
}
#auth-form > p {
    /* стили для всех объектов с тэгом p, являющихся дочерними элементами объекта с индексом auth-form */
}
main .cards > .txt {
    /* стили для всех объектов с классом txt, являющихся дочерними элементами объектов с классом cards, являющихся потомками объектов с тэгом main */
}
```

Таким образом можно выбрать объекты являющиеся дочерними каких угодно объектов.

#### Смежный селектор (для первого следующего)

Данный селектор выбирает на странице все объекты указанного 2 селектора, идущие сразу после объектов (в разметке html), указанного 1 селектора:

```css
body + a {
    /* стили для всех объектов с тэгом a, идущих сразу после объектов с тэгом body */
}
.main-container + p {
    /* стили для всех объектов с тэгом p, идущих сразу после объектов с классом main-container */
}
.card + .img {
    /* стили для всех объектов с классом img, идущих сразу после объектов с классом card */
}
#auth-form + p {
    /* стили для объекта с тэгом p, идущего сразу после объекта с индексом auth-form */
}
main .cards + .txt {
    /* стили для всех объектов с классом txt, идущих сразу после объектов с классом cards, являющихся потомками объектов с тэгом main */
}
```

Таким образом можно выбрать объекты сразу после каких угодно объектов в разметке html.

#### Смежный селектор (для всех сестренских после)

Данный селектор выбирает на странице все объекты указанного 2 селектора, находящиеся на том же уровне вложенности, что и объекты (в разметке html), указанного 1 селектора, и идущие после них:

```css
.header ~ .card {
    /* стили для всех объектов с классом card, идущих после объектов с классом card на том же уровне вложенности */
}
#auth-form ~ .container {
    /* стили для всех объектов с классом container, идущих сразу после объекта с индексом auth-form на том же уровне вложенности */
}
main .cards ~ .footer {
    /* стили для всех объектов с классом footer, идущих после объектов с классом cards на одинаковом уровне вложенности, и являющихся потомками объектов с тэгом main */
}
```

Таким образом можно выбрать все объекты, идущие после каких угодно объектов на одинаковом уровне вложенности в разметке html.

#### Групптровка селекторов

Если одинаковый набор стилей необходимо указать элементам с разными селекторами, то в таком случае можно перечислить селекторы через запятую:

```css
h1, h2, h3, h4, h5, h6 {
    /* Стили для заголовков любого уровня */
}
.txt, .link, .btn, .title {
    /* Стили для объектов, содержащих хотя бы один из указанных классов */
}
.card > .title,
.card > .img,
.card > .txt {
    /* Стили для элементов с классами title, img или txt, являющихся дочерними элементами объектов с классами card */
}
```

Таким образом можно сгрупптровать абсолютно любые селекторы

#### Объединение селекторов

Если мы хотим выбрать элементы, выбираемые несколькими селекторами, мы можем перечислить эти селекторы подряд без использования дополнительных символов и пробелов:

```css
.txt.btn {
    /* Стили для объектов, содержащих оба из указанных классов */
}
a.txt.btn {
    /* Стили для элементов с тэгом a и классами txt и btn */
}
```

#### Специфичность (приоритет) селекторов

Специфичность или приоритет css-селекторов определяет: правила, относящиесящиеся к каким селекторам могут переопределять правила, относящиеся к другим селекторам.

Во-первых, в css действует правило: **чем ниже объявлено правило - тем оно главнее**.

```css
.txt {
    color: red;
}
/* ... */
.link {
    color: blue;
}
```

В данном примере для объекта с классом `link`, также содержащим класс `txt`, цвет шрифта будет переопределен на синий (потому что это правило расположено ниже, чем то, которое задает красный цвет). При этом для объектов с классом `txt`, не содержащих класс `link`, цвет текста по-прежнему будет красным.

Но это правило работает только для селекторов с одинаковой базовой специфичностью (приоритетом).

Для оценки специфичности селекторов используется понятие `вес`, которое высчитывается по определенным правилам. Чем вес больше - тем приоритетней селектор, а значит, что правила, записанные для этого селектора могут переопределять правила для менее специфичных селекторов.

Рассмотрим пример:

```css
#auth-form {
    background-color: red;
}
/* ... */
.container {
    background-color: green;
}
```

Если у какого-то объекта будут указаны и индекс со значением `auth-form`, и класс со значением `container`, то цвет его фона будет красным, не смотря на то, что правило, устанавливающее зеленый цвет, написано ниже. Это происходит из-за того, что вес селектора по индексу выше, чем вес селектора по классу.

Этот пример также показывает правило, что если на один и тот же объект ссылаются два и более селекторов, то более специфичные селекторы будут переопределять правила менее спецевических - в порядке повышения веса.

Также стоит отметить, что общий селектор (`*`) имеет нулевой вес, а значит: указанные с его помощью правила могут быть перезаписаны с любым другим селектором.

##### Расчет веса селектора

Чтобы правильно оценить вес селектора, представим его значение в виде трех цифр, по умолчанию - нулей `000`:

1) селекторы по идентификатору увеличивают первую цифру

2) селекторы по классу, атрибуту и с псевдоклассами увеличивают вторую цифру

3) селекторы по тэгу и с псевдоэлементами увеличивают третью цифру

Полученное из этих цифр число как раз и обозначает вес селектора.

Рассмотрим примеры:

```css
#main {
    /* селектор состоит только из селектора по индексу, значит увеличиваем только первую цифру, получаем вес: 100 */
}
.main {
    /* селектор состоит только из селектора по классу, значит увеличиваем только вторую цифру, получаем вес: 10 */
}
main {
    /* селектор состоит только из селектора по тэгу, значит увеличиваем только третью цифру, получаем вес: 1 */
}

.item#main {
    /* селектор состоит из селектора по индексу и селектора по классу, значит увеличиваем первую и вторую цифры, получаем вес: 110 */
}
main#auth-form {
    /* селектор состоит из селектора по индексу и селектора по тэгу, значит увеличиваем первую и третью цифры, получаем вес: 101 */
}
main.item {
    /* селектор состоит из селектора по тэгу и селектора по классу, значит увеличиваем вторую и третью цифры, получаем вес: 11 */
}

main.main#main {
    /* селектор состоит из селектора по тэгу, селектора по классу и селектора по индексу, значит увеличиваем все три цифры, получаем вес: 111 */
}
```

Аналогично расчитывается веса всех других селекторов.

### [Переменные в CSS](https://youtu.be/OgPY8FccBkI?si=7qkjGiFdmUzBC7-L)

По ссылке из заголовка пункта - видео про переменные в css - **обязательно к просмотру**!

Момент, который немного сбижает язык стилей css с программированием - переменные. С их помощью можно задать некие значения, которые могут быть в дальнейшем использованы без необходимости вспоминать сами значения, достточно будет лишь указать соответствующую переменную.

Также использование переменных упрощает процесс поддержки кода. Представьте себе, что у вас в css стилях более нескольких сотен строк кода, среди которых в некоторых местах указан в качестве цвета заднего фона какой-то конкретный, например, черный. И вдруг вам ни с того ни с всего говорят: измени-ка ты, дружочек, цвет фона везде на какой-нибудь оттенок фиолетового. Без переменных вам придется рыскать по всему коду, выискивая правила, в которых нужно поменять цвет. в случае же использования переменных, вам нужно было бы поменять значение цвета только в одном месте - где вы задавали значение для переменной, а в остальных оно автоматически бы применилось, так как там используются переменные.

#### Как определить переменную в css?

Для этого нужно в блоке стилей указать новое свойство, начинающееся с двух дифисов `--`, и задать этому свойству интересующее значение. Желательно называть переменные понятным образом, чтобы при взгляде на них было сразу понятно, за что они отвечают. Названия переменных могут быть в любых регистрах:

```css
html {
    --dark-color: black;
    --STANDARD_COLOR: gray;
    --LightColor: white;
}
```

Однако рекомендуется придерживаться единообразного их написания, например, такого:

```css
html {
    --dark-color: black;
    --standard-color: gray;
    --light-color: white;
}
```

Чтобы использовать значения объявленных переменных, нужно у свойства указать функцию `var()`, в которую передать значение переменной:

```html
<button class="btn">Click</button>
```
```css
.btn {
    --dark-color: black;
    --standard-color: gray;
    --light-color: white;

    box-sizing: border-box;
    font-size: 20px;
    padding: 5px 20px;
    border: 2px solid var(--dark-color);
    border-radius: 10px;

    color: var(--light-color);
    background-color: var(--standard-color);
}
.btn:hover {
    color: var(--dark-color);
    background-color: var(--standard-color);
}
.btn:active {
    color: var(--light-color);
    background-color: var(--dark-color);
}
```
[Здесь](https://jsbin.com/kovatowajo/edit?html,css,output) вы можете посмотреть работу этого кода.

#### Область видимости переменных

Область видимости - это все те места, где доступна объявленная переменная. Область видимости переменной - это элемент, в блоке стилизации которого она объчвлена, а также все его элементы-потомки. Поэтому обычно переменные, задающие глобальные значения объявляют в блоке с селектором тэга `html`, ведь он является предком для всех остальных элементов. Глобальными значениями могут быть: размеры различных текстовых блоков, величины отступов между блоками в контейнерах, палитру цветов и многие другие.

Пример:

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>JS Bin</title>
</head>
<body class="body">
    <p class="txt">
      Lorem ipsum dolor sit amet, consectetur adipisicing elit. Aliquam velit ullam, magnam recusandae, aperiam consequatur ratione aut. Mollitia voluptatum ex repellendus quam est, animi, omnis amet quod, dolorem eos doloremque.
    </p>
    <button class="btn">Click</button>
</body>
</html>
```
```css
html {
    --dark-color: black;
    --standard-color: gray;
    --light-color: white;
    --standard-gap: 20px;
    --standard-font-size: 20px;
}

* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}


.body {
    display: flex;
    flex-direction: column;

    gap: var(--standard-gap);
    padding: var(--standard-gap);
    background-color: var(--standard-color);
}

.txt {
    font-size: var(--standard-font-size);
    color: var(--light-color);
}
.txt::selection {
    color: var(--light-color);
    background-color: var(--dark-color);
}

.btn {
    padding: 5px 20px;
    border-radius: 10px;

    font-size: var(--standard-font-size);
    border: 2px solid var(--dark-color);
    color: var(--dark-color);
    background-color: var(--standard-color);
}
.btn:hover {
    color: var(--light-color);
    background-color: var(--standard-color);
}
.btn:active {
    color: var(--light-color);
    background-color: var(--dark-color);
}
.btn::selection {
    color: var(--light-color);
    background-color: var(--dark-color);
}
.btn:active::selection {
    color: var(--dark-color);
    background-color: var(--light-color);
}
```
[Здесь](https://jsbin.com/kodaherafi/edit?html,css,output) вы можете посмотреть работу этого кода.

В данном примере переменные объявлены в блоке селектора тэга `html`, а значит они могут быть использованы в любом другом объекте. Если же вам не понравилась выбранная палитра цветов или какой-нибудь из размеров, вы всегда можете указать любые другие значения для этих переменных без необходимости переписывать свойства для каждого селектора.

#### Переопределение переменных

Значения переменных можно переопределять. Тогда для элементов-потомков объекта, в селекторе которого переопределили значение переменной будет уже новым. Это может быть полезно, например, для задания отступов между элементами контейнеров при их вложенности: у внешнего контейнера - большие осттупы, у его дочерних элементов - поменьше, у их дочерних элементов еще меньше и т.д.

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>JS Bin</title>
</head>
<body>
    <div>
        <div>
            <div>
                <p>
                    Lorem ipsum dolor sit amet, consectetur adipisicing elit. Tempora, a.
                </p>
                <p>
                    Lorem ipsum dolor sit amet, consectetur adipisicing elit. Tempora, a.
                </p>
            </div>
            <div>
                <p>
                    Lorem ipsum dolor sit amet, consectetur adipisicing elit. Tempora, a.
                </p>
                <p>
                    Lorem ipsum dolor sit amet, consectetur adipisicing elit. Tempora, a.
                </p>
            </div>
        </div>
        <div>
            <div>
                <p>
                    Lorem ipsum dolor sit amet, consectetur adipisicing elit. Tempora, a.
                </p>
                <p>
                    Lorem ipsum dolor sit amet, consectetur adipisicing elit. Tempora, a.
                </p>
            </div>
            <div>
                <p>
                    Lorem ipsum dolor sit amet, consectetur adipisicing elit. Tempora, a.
                </p>
                <p>
                    Lorem ipsum dolor sit amet, consectetur adipisicing elit. Tempora, a.
                </p>
            </div>
        </div>
    </div>
    <div>
        <div>
            <div>
                <p>
                    Lorem ipsum dolor sit amet, consectetur adipisicing elit. Tempora, a.
                </p>
                <p>
                    Lorem ipsum dolor sit amet, consectetur adipisicing elit. Tempora, a.
                </p>
            </div>
            <div>
                <p>
                    Lorem ipsum dolor sit amet, consectetur adipisicing elit. Tempora, a.
                </p>
                <p>
                    Lorem ipsum dolor sit amet, consectetur adipisicing elit. Tempora, a.
                </p>
            </div>
        </div>
        <div>
            <div>
                <p>
                    Lorem ipsum dolor sit amet, consectetur adipisicing elit. Tempora, a.
                </p>
                <p>
                    Lorem ipsum dolor sit amet, consectetur adipisicing elit. Tempora, a.
                </p>
            </div>
            <div>
                <p>
                    Lorem ipsum dolor sit amet, consectetur adipisicing elit. Tempora, a.
                </p>
                <p>
                    Lorem ipsum dolor sit amet, consectetur adipisicing elit. Tempora, a.
                </p>
            </div>
        </div>
    </div>
</body>
</html>
```
```css
html {
    --font-size: 20px;
    --gap: 60px;
    --width: 100%;
    --color-dark: black;
    --color-light: white;
    --bg-color: var(--color-dark);
    --font-color: var(--color-light);
    --columns-count: 1;
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body, div {
    display: grid;
    grid-template-columns: repeat(var(--columns-count), 1fr);
  
    color: var(--font-color);
    background-color: var(--bg-color);
    font-size: var(--font-size);
    padding: var(--gap);
    gap: var(--gap);
    border-radius: var(--gap);
}

div {
    --bg-color: var(--color-light);
    --font-color: var(--color-dark);
    --gap: 30px;
    --columns-count: 2;
}

div > div {
    --bg-color: var(--color-dark);
    --font-color: var(--color-light);
    --gap: 20px;
    --columns-count: 1;
}

div > div > div {
    --bg-color: var(--color-light);
    --font-color: var(--color-dark);
    --gap: 10px;
    --columns-count: 1;
}
```
[Здесь](https://jsbin.com/mehipajixe/edit?html,css,output) вы можете посмотреть работу этого кода.

В данном примере мы напрямую указали значения свойств во внешних блоках через переменные, благодаря чему, спускаясь вглубь, достаточно лишь переопределять значения переменных, чтобы реальные свойства также поменялись.

Фсе, я устал, иду спац...

## Домашка

### Download changes

Перед непосредственным выполнением домашней работы необходимо синхронизировать локальный и удаленный репозитории. Для этого скачиваем все изменения из удаленного репозитория с помощью команды:

```bash
git pull
```

Если на этом или последующих этапе возникает вопрос, ошибка или нестандартное поведение программы, пишите мне в личку, прикладывая скрин проблемы/ошибки, постараюсь помочь.

### Видосы

Обязательно посмотрите те два видео, ссылки на которые приведены в теоретическом блоке! 

### Упрощаем классы

Перед выполнением обязательно посмотрите [видео](https://youtu.be/GctszxSvbeQ?si=Lx9Oh-mqe9zrmXke).

На данный момент в нашем html-файлике практически у каждого объекта присутствуют классы, а у некоторых из них их даже 3 штуки. Большое количество классов у объектов затрудняет чтение кода, поэтому предлагаю немного их подсократить, а также добаить им немного смысла, чтобы глядя на название класса сразу было понятно, что он делает.

Итак, для начала оставьте в блоке стилизации универсального селектора только свойства, обнуляющие внутренние и внешние отступы, а такжже свойство `box-sizing`. Остальные -- удалите.

#### Текстовые элементы

На нашем сайте очень много текстовых элементов. Это и параграфы, и заголовки, и ссылки... Все эти объекты стилизуются похожим образом.

Итак, ваша задача -- определить смысловую нагрузку различных блоков на сайте и присвоить им соответствующие классы (один элемент - один класс):

- `big-txt` - большим текстовым блокам
- `txt` - обычным текстовым блокам
- `small-txt` - маленьким текстовым блокам
- `big-title` - большим заголовкам
- `title` - стандартным заголовкам
- `small-title` - маленьким заголовкам
- `txt-link` - текстовым ссылкам
- `txt-btn` - текстовым кнопкам

Теперь вспоминаем css-селекторы по атрибуту (разные их вариации), а также способы комбинации селекторов и стилизуем все текстовые элементы стрраницы с их помощью.

Например, чтобы задать базовые свойства для всех текстов и заголовков вы можете использовать css-селекторы по атрибуту, выбирая вариацию с включением фрагмента атрибута `class`:

```css
[class*="txt"],
[class*="title"] {
    font-family: "Ubuntu", sans-serif;
    color: blueviolet;
    font-size: 20px;
}
```

Напомню, что данные селекторы выбирают все html-элементы, у которых присутствует атрибут `class`, значение которого включает в себя фрагменты `txt` или `title`, то есть такие селекторы выбирут все элементы, у которых есть описанные выше классы.

При добавлении остальных блоков стилизации учитывайте специфичность селекторов, чтобы не получилась ситуация, когда вместо конкретного стиля у объекта будет его общее значение.

Также не забываем добавить изменение цветов при выделении текста этих объектов с помощью псевдоэлемента `::selection`:

```css
[class*="txt"]::selection,
[class*="title"]::selection {
    background-color: blueviolet;
    color: white;
}
```

Ранее добавленные простые классы `btn` и `link` удалите.

#### Контейнеры

Мы с вами ранее изучали Grid и Flex layout-ы и использовали их возможности для позиционирования объектов на наших страницах. Для этого мы добавляли такие классы, как `one-line-flex-container`, `one-column-flex-container`, `three-column-grid-container` и другие. Теперь некоторые из этих классов мы подсократим, а некоторые просто заменим.

Итак, вы должны проанализировать текущую версию разметки и определить, какие фрагменты страницы, логически к чему относятся, и добавить им соответствующие классы:

- `column-flex-container` - флекс-контейнер, элементы которого располагаются в колонку
- `line-flex-contsiner` - флекс-контейнер, элементы которого располагаются в строчку
- `cards-grid-container` - грид-контейнер, содержащий карточки товаров
- `card-grid-container` - грид-контейнер для карточки товара

При этом старые классы нужно удалить.

Теперь стилизуйте объекты, содержащие данные классы, причем выявляйте более общие стили и применяйте для более общих селекторов, например, стилизовать данные флекс контейнеры можно так:

```css
[class*="container"] {
    gap: 30px;
}

[class*="flex-container"] {
    display: flex;
    align-items: center;
}
[class*="column-flex-container"] {
    flex-direction: column;
}
[class*="line-flex-container"] {
    flex-direction: row;
    justify-content: space-between;
}
```

В данном примере используются селекторы по атрибуту, выявляющие элементы, значение атрибута `class` которых содержит указанные фрагменты. Таким образом, стили в блоке по селектору `[class*="container"]` применятся вообще ко всем элементам, у которых в названиях классов хотя бы раз встречается `container`, а значит, что не нужно будет теперь прописывать свойство `gap` конкретно каждому контейнеру.

#### Базовые блоки

На текущий момент у ваших базовых блоков должно быть минимум по два класса: `main-container` и `main-<header или footer>` или `main`. Теперь вместо этих классов пропишите им такой: `main-container-<header, main или footer>` -- в зависимости от элемента, которому его добавляете.

Теперь, там, где вы ранее стилизовали элементы по селектору `.main-container`, используйте селектор `[class|="main-container"]` или `[class*="main-container"]`. К сожалению, для добавления уникальных стилей каждому из базовых блоков придется использовать селекторы по классу, которые тпеперь стали длиннее: `.main-container-header`, `.main-container-main` и `.main-container-footer`.

#### Шапка сайта

Так как у нас идет мода на упрощение, то заменяем класс `main-nav` у навигвции на класс `nav`.

Теперь, чтобы стилизовать элементы контейнеров, используйте селектор прямого потомка. Например, навигация -- прямой потомок (дочерний элемент) базового блока (шапки сайта), а это значит, что ее можно стилизовать с помощью селектора:

```css
.main-container-header > .nav {
    /* Стили для навигации в шапке сайта */
}
```

Использовать аналогичный селектор можно и для кнопки:

```css
.main-container-header > [class*="btn"] {
    /* Стили для кнопки, которая - в шапке сайта */
}
```

#### Карточки товаров

Так как для блока-контейнера, содержащего карточки товаров был добавлен класс `cards-grid-container`, то теперь его можно стилизовать при помощи селектора:

```css
[class|="cards"] {
    /* Стили для контейнера, содержащего карточки товаров */
}
```

Аналогично карточки товаров можно стилизовать с помощью селектора:

```css
[class|="card"] {
    /* Стили для карточек товаров */
}
```

Ну и как вы могли догадаться, дочерние элементы карточек товаров можно стилизовать с помощью примерно таких селекторов:

```css
[class|="card"] > [class*="title"],
[class|="card"] > [class*="txt"] {
    /* Стили для всех текстовых блоков и заголовков,
    у которых родительский элемент имеет атрибут class со значением,
    начинающимся на card- */
}
```

Снова напомню про специфисность селекторов, следите за тем, чтобы случайно **не переопределить важное свойство**!

### Переменные

Перед выполнением обязательно посмотрите [видео](https://youtu.be/OgPY8FccBkI?si=F8WPU0VDJ3zTIbT7).

Итак, вам нужно проанализировать вашу страничку и определить в ней закономерности: как меняются цвета из выбранной цветовой палитры, как меняются различные размеры и отступы и т.д.

#### Цвета

Проанализируйте используемые на сайте цвета. Базово они должны входить в одну из групп: светные и темные.

Итак, выберите основной цвет для вашей страницы. К нему нужно подобрать несколько других, хорошо с ним сочетающихся, при этом чтобы все цвета можно было однозначно обозначить:

1) `lightest` - очень светный цвет (мб даже белый), желательно оттенок базового
2) `light` - светный цвет, желательно оттенок базового
3) `base` - выбранный базовый цвет
4) `dark` - темный цвет, желательно оттенок базового цвета
5) `darkest` - еще более темный цвет (мб даже черный), желательно оттенок базового

Если вам понадобится еще какой-нибудь цвет, то можете добавить его, только подберите логичное название по аналогии с теми, которые выше.

Для всех цветов подберите оттенок, смещенный в серую сторону -- для теней:

1) `lightest-shadow`
2) `light-shadow`
3) `base-shadow`
4) `dark-shadow`
5) `darkest-shadow`

Теперь в самом верху css-файла в блоке стилей для селектора `html` опреджелите css-переменные с соответствующими названиями и выбранными цветами.

Также подберите полупрозрачные оттенки каждого из цветов и создайте на их основе переменные:

1) `lightest-transparent`
2) `light-transparent`
3) `base-transparent`
4) `dark-transparent`
5) `darkest-transparent`

Полупрозрачные цвета можно сделать, используя функцию `rgba()` со значением альфа-канала `0.5` -- загуглите, есличо.

Также в блоке с селектором `html` добавьте переменные:

- `color` - для цвета текста
- `bg-color` - для цвета фона

И задайте им значения из переменных, добавленных ранее. Причем цвет тени должен соответствовать цвету фона.

Эти значения могут в дальнейшем при необходимости быть изменены на другие из выбранной цветовой палитры.

#### Размеры

Различные размеры -- часто встречаются в стилизации. Чтобы удобно управлять их величинами определите в блоке селектора `head` несколько переменных:

- `smallest-size` - для минимального размера, например, 5 пикселей
- `small-size` - для маленького размера, например, 10 пикселей
- `std-size` - для стандартного размера, например, 20 пикселей
- `big-size` - для большого размера, например, 30 пикселей
- `bigest-size` - для увеличенного размера размера, например, 40 пикселей
- `giant-size` - для гигантского размера, например, 60 пикселей

Эти размеры будут использоваться для задания всевозможных отступов, а для размеров шрифтов создайте переменные:

- `smallest-font-size` - минимальный размер шрифта (например, 16 пикселей)
- `small-font-size` - маленький размер шрифта (например, 20 пикселей)
- `medium-font-size` - средний размер шрифта (например, 24 пикселя)
- `big-font-size` - большой размер шрифта (например, 28 пикселей)
- `bigest-font-size` - увеличенный размер шрифта (например, 36 пикселей)
- `giant-font-size` - гигантский размер шрифта (например, 44 пикселей)

Также определите переменные для конкретных свойств:

- `font-size` - для размера шрифта (по умолчанию задайте значение маленького размера шрифта)
- `padding` - для размера внутреннего отступа (по умолчанию задайте 0)
- `gap` - для размера отступов между элементами контейнера (по умолчанию задайте 0)

Использовать эти элементы стилизации мы будем уже на занятии.

### Результат

Когда/если вы все правильно сделаете, ваша страничка не должна измениться (если только вы не захотели в ней что-то переделать).

### Pass task
Когда выполнили все задания, добавляете измененные файлы проекта в индекс гита, создаете коммит, отправляете на GitHub:
```bash
# Добавляем измененные файлы в индекс гита (. - добавить все)
git add .

# Создаем коммит на основании изщменений, добавленных в индекс гита, задаем сообщение коммита
git commit -m "Finally done my homework to 2024-12-29"

# Загружаем изменения в удаленный репозиторий на гитхабе
git push
```
После этого скидываете мне в личку ссылку на ваш гитхаб-репозиторий. Если скинете до пятницы 6 часов вечера, то в течение суток гарантированно получите обратную связь с разбором ошибок и предложениями по улучшению.

### Recomendations
- группируйте CSS-селекторы разных объектов вместе, если задаете им одинаковые правила,
- делайте и сдавайте дз как можно раньше, чтобы я успел проверить и дать фидбэк.

#### Всем удачи!